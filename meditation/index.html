<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220" />
  <title>Breath Trainer</title>
  <style>
    :root{
      --bg:#0b1220;
      --text:#e8eefc;
      --muted:#a9b6d3;
      --accent:#7aa8ff;
      --good:#7dffa8;
      --warn:#ffd27a;
      --danger:#ff7a7a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --btnRadius: 16px;
      --tap: 52px;
    }
    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 30% -10%, rgba(122,168,255,.18), transparent 60%),
                  radial-gradient(1000px 800px at 90% 10%, rgba(125,255,168,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      -webkit-font-smoothing: antialiased;
      padding: env(safe-area-inset-top) 14px env(safe-area-inset-bottom) 14px;
    }
    .app{max-width:820px;margin:0 auto;display:flex;flex-direction:column;gap:12px;min-height:100%;}
    header{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;padding:8px 4px 0;}
    .title{display:flex;flex-direction:column;gap:4px;}
    .title h1{font-size:18px;margin:0;letter-spacing:.2px;}
    .title p{margin:0;color:var(--muted);font-size:12.5px;line-height:1.2;}
    .pill{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      display:flex;gap:8px;align-items:center;user-select:none;
    }
    .dot{width:9px;height:9px;border-radius:50%;background:rgba(255,255,255,.25);box-shadow:0 0 0 4px rgba(255,255,255,.06);}
    .dot.running{ background: var(--good); box-shadow: 0 0 0 4px rgba(125,255,168,.12); }
    .dot.paused{ background: var(--warn); box-shadow: 0 0 0 4px rgba(255,210,122,.12); }

    .grid{display:grid;grid-template-columns:1fr;gap:12px;}
    @media(min-width:860px){.grid{grid-template-columns:1.2fr .8fr;align-items:start;}}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .inner{ padding: 14px; }
    .stage{display:flex;flex-direction:column;gap:14px;min-height:410px;}

    .visualWrap{display:flex;align-items:center;justify-content:center;padding:12px 0 6px;}
    .orb{
      width: min(64vw, 320px);
      aspect-ratio: 1 / 1;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.22), rgba(255,255,255,.04) 48%, rgba(122,168,255,.10) 70%, rgba(0,0,0,0) 72%),
                  radial-gradient(circle at 70% 70%, rgba(125,255,168,.18), transparent 45%);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 18px 70px rgba(0,0,0,.45);
      transform: scale(0.72);
      will-change: transform;
      position:relative;
    }
    .orb::after{
      content:"";
      position:absolute;
      inset: -10%;
      border-radius: 50%;
      border: 1px solid rgba(122,168,255,.08);
      filter: blur(.2px);
    }

    .readouts{display:flex;justify-content:space-between;gap:10px;align-items:flex-end;}
    .big{font-size: clamp(22px, 4.4vw, 34px);font-weight:750;letter-spacing:.4px;margin:0;line-height:1.05;}
    .sub{margin:0;color: var(--muted);font-size:13px;}
    .timer{display:flex;flex-direction:column;align-items:flex-end;gap:4px;min-width:150px;}
    .time{font-variant-numeric: tabular-nums;font-size:22px;font-weight:720;margin:0;}
    .smallTime{font-variant-numeric: tabular-nums;margin:0;font-size:13px;color: var(--muted);}

    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:4px;}
    button, input, select{font: inherit;color: inherit;}
    .btn{
      height: var(--tap);
      padding: 0 14px;
      border-radius: var(--btnRadius);
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.primary{background: linear-gradient(180deg, rgba(122,168,255,.22), rgba(122,168,255,.10));border-color: rgba(122,168,255,.35);}
    .btn.danger{background: linear-gradient(180deg, rgba(255,122,122,.20), rgba(255,122,122,.08));border-color: rgba(255,122,122,.35);}
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.55; }

    .seg{display:flex;gap:8px;flex-wrap:wrap;}
    .chip{
      height: 42px;padding: 0 12px;border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      color: var(--text);
      font-size: 13px;
      display:flex;align-items:center;gap:8px;
      -webkit-tap-highlight-color: transparent;
    }
    .chip.active{border-color: rgba(122,168,255,.45);background: rgba(122,168,255,.14);}

    .row{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;}
    .row > *{ flex: 1 1 auto; }
    .label{font-size:12.5px;color:var(--muted);margin:0 0 6px 2px;}
    .field{display:flex;flex-direction:column;min-width:160px;}

    select, input[type="number"], input[type="range"]{
      width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding: 12px 12px;
      height: 46px;
      outline: none;
    }
    input[type="range"]{height:42px;padding:0 10px;}

    .twoCol{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    @media(max-width:420px){.twoCol{grid-template-columns:1fr;}}

    .mini{font-size:12px;color:var(--muted);line-height:1.35;margin:8px 2px 0;}

    .toggle{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding: 10px 12px;border-radius: 14px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
    }
    .toggle span{font-size:13px;color:var(--text);}
    .switch{
      width: 46px; height: 28px;border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.12);
      position:relative;flex:0 0 auto;
    }
    .switch::after{
      content:"";position:absolute;top:3px;left:3px;
      width:22px;height:22px;border-radius:50%;
      background: rgba(255,255,255,.85);
      transition: transform .18s ease;
    }
    .switch.on{background: rgba(122,168,255,.25);border-color: rgba(122,168,255,.35);}
    .switch.on::after{ transform: translateX(18px); }

    footer{margin-top:auto;padding:6px 2px 10px;color: rgba(169,182,211,.75);font-size:11.5px;line-height:1.35;text-align:center;}
    @media (prefers-reduced-motion: reduce){
      .orb{ transition:none !important; }
      *{ scroll-behavior: auto !important; }
    }
  </style>
</head>

<body>
<div class="app">
  <header>
    <div class="title">
      <h1>Breath Trainer</h1>
      <p>Preset timers + customizable breathing patterns + configurable bells (no background noise).</p>
    </div>
    <div class="pill" aria-live="polite">
      <div id="statusDot" class="dot"></div>
      <div id="statusText">Idle</div>
    </div>
  </header>

  <div class="grid">
    <!-- LEFT: MAIN STAGE -->
    <section class="card stage" aria-label="Breathing stage">
      <div class="inner">
        <div class="visualWrap">
          <div id="orb" class="orb" role="img" aria-label="Breathing visual"></div>
        </div>

        <div class="readouts">
          <div>
            <p id="phaseBig" class="big">Ready</p>
            <p id="phaseSub" class="sub">Select a timer, choose a pattern, then Start.</p>
          </div>
          <div class="timer">
            <p class="smallTime">Session</p>
            <p id="sessionLeft" class="time">--:--</p>
            <p id="phaseLeft" class="smallTime">Phase: --</p>
          </div>
        </div>

        <div class="controls" style="margin-top:12px;">
          <button id="btnStart" class="btn primary">Start</button>
          <button id="btnPause" class="btn" disabled>Pause</button>
          <button id="btnReset" class="btn danger" disabled>Reset</button>
          <button id="btnPreviewPhase" class="btn">Preview phase bell</button>
        </div>

        <p class="mini">
          Audio on mobile requires a tap. Bells are short and will always stop on Pause/Reset.
        </p>
      </div>
    </section>

    <!-- RIGHT: SETTINGS -->
    <aside class="card" aria-label="Settings">
      <div class="inner">
        <!-- TIMER -->
        <div class="field">
          <div class="label">Session timer</div>
          <div class="seg" id="timerChips">
            <button class="chip" data-min="5">5 min</button>
            <button class="chip" data-min="10">10 min</button>
            <button class="chip" data-min="15">15 min</button>
            <button class="chip" data-min="20">20 min</button>
          </div>
          <div style="height:10px;"></div>
          <div class="row">
            <div class="field" style="min-width:140px;">
              <div class="label">Custom minutes</div>
              <input id="customMinutes" type="number" min="1" max="180" step="1" value="10" inputmode="numeric" />
            </div>
            <div class="field" style="min-width:120px;">
              <div class="label">&nbsp;</div>
              <button id="applyCustom" class="btn">Use custom</button>
            </div>
          </div>
        </div>

        <div style="height:14px;"></div>

        <!-- BREATH PATTERN -->
        <div class="field">
          <div class="label">Breathing preset</div>
          <select id="presetSelect" aria-label="Breathing presets">
            <option value="box">Box 4–4–4–4</option>
            <option value="478">4–7–8</option>
            <option value="resonant">Resonant 5–0–5–0</option>
            <option value="calm">Calm 6–2–6–0</option>
            <option value="energize">Energize 3–0–6–0</option>
          </select>

          <div style="height:12px;"></div>

          <div class="twoCol">
            <div class="field">
              <div class="label">Inhale (s)</div>
              <input id="inhale" type="number" min="1" max="30" value="4" inputmode="numeric" />
            </div>
            <div class="field">
              <div class="label">Hold 1 (s)</div>
              <input id="hold1" type="number" min="0" max="30" value="4" inputmode="numeric" />
            </div>
            <div class="field">
              <div class="label">Exhale (s)</div>
              <input id="exhale" type="number" min="1" max="30" value="4" inputmode="numeric" />
            </div>
            <div class="field">
              <div class="label">Hold 2 (s)</div>
              <input id="hold2" type="number" min="0" max="30" value="4" inputmode="numeric" />
            </div>
          </div>

          <p id="cycleInfo" class="mini"></p>
        </div>

        <div style="height:14px;"></div>

        <!-- BELLS -->
        <div class="field">
          <div class="label">Bell sounds</div>

          <div class="toggle" role="button" tabindex="0" id="toggleBellPhase" aria-pressed="false">
            <span>Bell on phase change</span>
            <div class="switch" id="bellPhaseSwitch" aria-hidden="true"></div>
          </div>

          <div style="height:10px;"></div>

          <div class="row">
            <div class="field" style="min-width: 200px;">
              <div class="label">Phase-change bell</div>
              <select id="phaseBellSelect" aria-label="Phase bell select">
                <option value="bowl">Tibetan Bowl</option>
                <option value="chime">Soft Chime</option>
                <option value="crystal">Crystal Bell</option>
                <option value="wood">Wood Block</option>
                <option value="triangle">Triangle</option>
                <option value="temple">Temple Bell</option>
                <option value="gong">Zen Gong (Soft)</option>
                <option value="windchime">Wind Chimes</option>
                <option value="kalimba">Kalimba Pluck</option>
                <option value="handpan">Handpan Tap</option>
                <option value="deepbowl">Deep Bowl</option>
                <option value="glass">Glass Ping</option>
                <option value="waterdrop">Water Drop</option>
                <option value="marimba">Marimba Click</option>
                <option value="shimmer">Shimmer Bell</option>
              </select>
            </div>
            <div class="field" style="min-width: 140px;">
              <div class="label">&nbsp;</div>
              <button id="previewPhaseBell" class="btn">Preview</button>
            </div>
          </div>

          <div style="height:10px;"></div>

          <div class="toggle" role="button" tabindex="0" id="toggleBellEnd" aria-pressed="true">
            <span>Bell at session end</span>
            <div class="switch on" id="bellEndSwitch" aria-hidden="true"></div>
          </div>

          <div style="height:10px;"></div>

          <div class="row">
            <div class="field" style="min-width: 200px;">
              <div class="label">End-session bell</div>
              <select id="endBellSelect" aria-label="End bell select">
                <option value="bowl">Tibetan Bowl</option>
                <option value="chime" selected>Soft Chime</option>
                <option value="crystal">Crystal Bell</option>
                <option value="wood">Wood Block</option>
                <option value="triangle">Triangle</option>
                <option value="temple">Temple Bell</option>
                <option value="gong">Zen Gong (Soft)</option>
                <option value="windchime">Wind Chimes</option>
                <option value="kalimba">Kalimba Pluck</option>
                <option value="handpan">Handpan Tap</option>
                <option value="deepbowl">Deep Bowl</option>
                <option value="glass">Glass Ping</option>
                <option value="waterdrop">Water Drop</option>
                <option value="marimba">Marimba Click</option>
                <option value="shimmer">Shimmer Bell</option>
              </select>
            </div>
            <div class="field" style="min-width: 140px;">
              <div class="label">&nbsp;</div>
              <button id="previewEndBell" class="btn">Preview</button>
            </div>
          </div>

          <div style="height:10px;"></div>

          <div class="field">
            <div class="label">Bell volume</div>
            <input id="bellVolume" type="range" min="0" max="100" value="35" />
          </div>
        </div>

        <div style="height:14px;"></div>

        <!-- WAKE LOCK -->
        <div class="toggle" role="button" tabindex="0" id="toggleWake" aria-pressed="false">
          <span>Keep screen awake (if supported)</span>
          <div class="switch" id="wakeSwitch" aria-hidden="true"></div>
        </div>

        <p class="mini">
          This is guidance software — not medical advice. Keep breath holds comfortable.
        </p>
      </div>
    </aside>
  </div>

  <footer>
    Offline-first • No tracking • Audio starts after tap (mobile browser rule)
  </footer>
</div>

<script>
(() => {
  // -----------------------------
  // Utilities
  // -----------------------------
  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
  const pad2 = (n) => String(n).padStart(2, "0");
  const mmss = (s) => `${pad2(Math.floor(s/60))}:${pad2(Math.floor(s%60))}`;

  // -----------------------------
  // DOM
  // -----------------------------
  const orb = $("orb");
  const phaseBig = $("phaseBig");
  const phaseSub = $("phaseSub");
  const sessionLeftEl = $("sessionLeft");
  const phaseLeftEl = $("phaseLeft");

  const btnStart = $("btnStart");
  const btnPause = $("btnPause");
  const btnReset = $("btnReset");
  const btnPreviewPhase = $("btnPreviewPhase");

  const timerChips = $("timerChips");
  const customMinutes = $("customMinutes");
  const applyCustom = $("applyCustom");

  const presetSelect = $("presetSelect");
  const inhaleEl = $("inhale");
  const hold1El = $("hold1");
  const exhaleEl = $("exhale");
  const hold2El = $("hold2");
  const cycleInfo = $("cycleInfo");

  const toggleBellPhase = $("toggleBellPhase");
  const bellPhaseSwitch = $("bellPhaseSwitch");
  const toggleBellEnd = $("toggleBellEnd");
  const bellEndSwitch = $("bellEndSwitch");

  const phaseBellSelect = $("phaseBellSelect");
  const endBellSelect = $("endBellSelect");
  const previewPhaseBell = $("previewPhaseBell");
  const previewEndBell = $("previewEndBell");
  const bellVolumeEl = $("bellVolume");

  const toggleWake = $("toggleWake");
  const wakeSwitch = $("wakeSwitch");

  const statusDot = $("statusDot");
  const statusText = $("statusText");

  // -----------------------------
  // State
  // -----------------------------
  const PRESETS = {
    box:      { inhale: 4, hold1: 4, exhale: 4, hold2: 4 },
    "478":    { inhale: 4, hold1: 7, exhale: 8, hold2: 0 },
    resonant: { inhale: 5, hold1: 0, exhale: 5, hold2: 0 },
    calm:     { inhale: 6, hold1: 2, exhale: 6, hold2: 0 },
    energize: { inhale: 3, hold1: 0, exhale: 6, hold2: 0 },
  };

  const STORAGE_KEY = "breath_trainer_v2";

  let settings = {
    sessionSeconds: 10 * 60,
    inhale: 4,
    hold1: 4,
    exhale: 4,
    hold2: 4,
    preset: "box",

    bellOnPhase: false,
    bellOnEnd: true,

    phaseBell: "bowl",
    endBell: "chime",
    bellVolume: 35,

    keepAwake: false,
  };

  let running = false;
  let paused = false;

  // Session timing
  let sessionTotal = settings.sessionSeconds;
  let sessionRemaining = settings.sessionSeconds;
  let phaseRemaining = 0;

  // Breath cycle
  let phases = []; // {name, seconds, mode}
  let phaseIndex = 0;
  let phaseStartTs = 0; // performance.now
  let lastTickTs = 0;

  // Wake lock
  let wakeLock = null;

  // -----------------------------
  // Audio (bells only)
  // -----------------------------
  let audioCtx = null;
  let master = null;

  // Track currently ringing nodes so Pause/Reset can hard-stop them.
  let activeBellStops = [];

  const ensureAudio = async () => {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      master = audioCtx.createGain();
      master.gain.value = (settings.bellVolume / 100);
      master.connect(audioCtx.destination);
    }
    if (audioCtx.state === "suspended") {
      await audioCtx.resume();
    }
  };

  const stopAllBells = () => {
    const stops = activeBellStops.slice();
    activeBellStops = [];
    for (const s of stops) {
      try { s(); } catch {}
    }
  };

  const setBellVolume = (v) => {
    settings.bellVolume = clamp(v, 0, 100);
    if (master) master.gain.value = settings.bellVolume / 100;
    save();
  };

  const playBell = async (type) => {
    await ensureAudio();

    // Hard stop any currently ringing bell so Stop/Reset/Pause never leaves a tail.
    stopAllBells();

    const t0 = audioCtx.currentTime;
    const out = audioCtx.createGain();
    out.gain.value = 1.0;
    out.connect(master);

    const cleanup = [];
    const stop = () => {
      for (const fn of cleanup) { try { fn(); } catch {} }
      try { out.disconnect(); } catch {}
    };

    // helper: envelope
    const env = (gainNode, attack, decay, peak) => {
      gainNode.gain.setValueAtTime(0.0001, t0);
      gainNode.gain.exponentialRampToValueAtTime(peak, t0 + attack);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, t0 + attack + decay);
    };

    // Gentle lowpass
    const lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 5200;
    lp.Q.value = 0.6;
    lp.connect(out);
    cleanup.push(() => { try { lp.disconnect(); } catch {} });

    // Subtle shimmer delay
    const delay = audioCtx.createDelay();
    delay.delayTime.value = 0.065;
    const fb = audioCtx.createGain();
    fb.gain.value = 0.18;
    delay.connect(fb);
    fb.connect(delay);
    delay.connect(lp);
    cleanup.push(() => { try { delay.disconnect(); } catch {} });
    cleanup.push(() => { try { fb.disconnect(); } catch {} });

    const connectTo = (node, withDelay = false) => {
      if (withDelay) node.connect(delay);
      node.connect(lp);
    };

    if (type === "bowl") {
      // Tibetan bowl
      const g = audioCtx.createGain();
      env(g, 0.01, 3.2, 0.24);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      o1.type = "sine";
      o2.type = "sine";

      o1.frequency.setValueAtTime(220, t0);
      o2.frequency.setValueAtTime(440, t0);
      o1.detune.setValueAtTime(-4, t0);
      o2.detune.setValueAtTime(3, t0);

      const lfo = audioCtx.createOscillator();
      const lfoG = audioCtx.createGain();
      lfo.type = "sine";
      lfo.frequency.value = 5.2;
      lfoG.gain.value = 0.015;
      lfo.connect(lfoG);
      lfoG.connect(g.gain);

      o1.connect(g);
      o2.connect(g);
      connectTo(g, true);

      o1.start(t0); o2.start(t0); lfo.start(t0);
      o1.stop(t0 + 3.4); o2.stop(t0 + 3.1); lfo.stop(t0 + 3.4);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { lfo.stop(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "chime") {
      // Soft chime
      const g = audioCtx.createGain();
      env(g, 0.005, 0.85, 0.20);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      o1.type = "triangle";
      o2.type = "sine";

      const f = 740;
      o1.frequency.setValueAtTime(f, t0);
      o2.frequency.setValueAtTime(f * 2.01, t0);

      o1.connect(g);
      o2.connect(g);
      connectTo(g, true);

      o1.start(t0); o2.start(t0);
      o1.stop(t0 + 0.95); o2.stop(t0 + 0.85);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "crystal") {
      // Crystal bell
      const g = audioCtx.createGain();
      env(g, 0.006, 1.35, 0.18);

      const carrier = audioCtx.createOscillator();
      const mod = audioCtx.createOscillator();
      const modG = audioCtx.createGain();

      carrier.type = "sine";
      mod.type = "sine";

      const base = 880;
      carrier.frequency.setValueAtTime(base, t0);
      carrier.frequency.exponentialRampToValueAtTime(base * 1.08, t0 + 0.12);

      mod.frequency.setValueAtTime(6.5 * base, t0);
      modG.gain.setValueAtTime(0, t0);
      modG.gain.linearRampToValueAtTime(45, t0 + 0.02);
      modG.gain.exponentialRampToValueAtTime(0.001, t0 + 0.55);

      mod.connect(modG);
      modG.connect(carrier.frequency);

      carrier.connect(g);
      connectTo(g, true);

      carrier.start(t0); mod.start(t0);
      carrier.stop(t0 + 1.45); mod.stop(t0 + 0.7);

      cleanup.push(() => { try { carrier.stop(); } catch {} });
      cleanup.push(() => { try { mod.stop(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });
      cleanup.push(() => { try { modG.disconnect(); } catch {} });

    } else if (type === "wood") {
      // Wood block
      const dur = 0.12;
      const sr = audioCtx.sampleRate;
      const len = Math.floor(sr * dur);
      const buf = audioCtx.createBuffer(1, len, sr);
      const data = buf.getChannelData(0);
      for (let i=0;i<len;i++){
        const white = Math.random()*2-1;
        const a = Math.pow(1 - i/len, 2.2);
        data[i] = white * a;
      }

      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = 520;
      bp.Q.value = 7.0;

      const g = audioCtx.createGain();
      env(g, 0.001, 0.18, 0.30);

      src.connect(bp);
      bp.connect(g);
      connectTo(g, false);

      src.start(t0);
      src.stop(t0 + dur);

      cleanup.push(() => { try { src.stop(); } catch {} });
      cleanup.push(() => { try { src.disconnect(); } catch {} });
      cleanup.push(() => { try { bp.disconnect(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "triangle") {
      // Triangle
      const g = audioCtx.createGain();
      env(g, 0.003, 0.95, 0.16);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      o1.type = "sine";
      o2.type = "sine";

      const f = 1046;
      o1.frequency.setValueAtTime(f, t0);
      o2.frequency.setValueAtTime(f * 1.5, t0);

      const g2 = audioCtx.createGain();
      g2.gain.value = 0.35;

      o1.connect(g);
      o2.connect(g2);
      g2.connect(g);

      connectTo(g, true);

      o1.start(t0); o2.start(t0);
      o1.stop(t0 + 1.05); o2.stop(t0 + 0.85);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });
      cleanup.push(() => { try { g2.disconnect(); } catch {} });

    } else if (type === "temple") {
      // Temple Bell
      lp.frequency.value = 4200;
      const g = audioCtx.createGain();
      env(g, 0.004, 1.35, 0.18);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      const o3 = audioCtx.createOscillator();
      o1.type = "sine";
      o2.type = "sine";
      o3.type = "sine";

      const f = 620;
      o1.frequency.setValueAtTime(f, t0);
      o2.frequency.setValueAtTime(f * 2.07, t0);
      o3.frequency.setValueAtTime(f * 3.12, t0);

      const g2 = audioCtx.createGain();
      g2.gain.value = 0.42;
      const g3 = audioCtx.createGain();
      g3.gain.value = 0.22;

      o1.connect(g);
      o2.connect(g2); g2.connect(g);
      o3.connect(g3); g3.connect(g);
      connectTo(g, true);

      o1.start(t0); o2.start(t0); o3.start(t0);
      o1.stop(t0 + 1.55); o2.stop(t0 + 1.25); o3.stop(t0 + 1.0);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { o3.stop(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });
      cleanup.push(() => { try { g2.disconnect(); } catch {} });
      cleanup.push(() => { try { g3.disconnect(); } catch {} });

    } else if (type === "gong") {
      // Zen Gong (Soft)
      lp.frequency.value = 3200;
      const g = audioCtx.createGain();
      env(g, 0.02, 2.6, 0.22);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      o1.type = "sine";
      o2.type = "triangle";

      const base = 130;
      o1.frequency.setValueAtTime(base, t0);
      o2.frequency.setValueAtTime(base * 2.02, t0);

      o1.frequency.exponentialRampToValueAtTime(base * 1.04, t0 + 0.12);
      o2.frequency.exponentialRampToValueAtTime(base * 2.08, t0 + 0.16);

      const sat = audioCtx.createWaveShaper();
      const curve = new Float32Array(256);
      for (let i=0;i<256;i++){
        const x = (i/255)*2 - 1;
        curve[i] = Math.tanh(1.2 * x);
      }
      sat.curve = curve;

      o1.connect(sat);
      o2.connect(sat);
      sat.connect(g);
      connectTo(g, true);

      o1.start(t0); o2.start(t0);
      o1.stop(t0 + 2.9); o2.stop(t0 + 2.5);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { sat.disconnect(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "windchime") {
      // Wind Chimes
      lp.frequency.value = 5200;
      const g = audioCtx.createGain();
      env(g, 0.002, 0.95, 0.18);

      const freqs = [1320, 1480, 1760, 1980, 2220];
      const oscs = [];
      for (let i=0;i<4;i++){
        const o = audioCtx.createOscillator();
        o.type = "sine";
        const f = freqs[Math.floor(Math.random() * freqs.length)] * (0.98 + Math.random()*0.05);
        o.frequency.setValueAtTime(f, t0);
        oscs.push(o);
        o.connect(g);
      }
      connectTo(g, true);

      oscs.forEach(o => o.start(t0));
      oscs.forEach((o, idx) => o.stop(t0 + 0.55 + idx*0.08));

      cleanup.push(() => { oscs.forEach(o => { try { o.stop(); } catch {} }); });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "kalimba") {
      // Kalimba Pluck
      lp.frequency.value = 3800;
      const g = audioCtx.createGain();
      env(g, 0.002, 0.55, 0.20);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      o1.type = "triangle";
      o2.type = "sine";
      const f = 520;
      o1.frequency.setValueAtTime(f, t0);
      o2.frequency.setValueAtTime(f * 2.0, t0);

      const lp2 = audioCtx.createBiquadFilter();
      lp2.type = "lowpass";
      lp2.frequency.setValueAtTime(2400, t0);
      lp2.Q.value = 0.9;

      o1.connect(lp2);
      o2.connect(lp2);
      lp2.connect(g);
      connectTo(g, true);

      o1.start(t0); o2.start(t0);
      o1.stop(t0 + 0.62); o2.stop(t0 + 0.45);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { lp2.disconnect(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "handpan") {
      // Handpan Tap
      lp.frequency.value = 3400;
      const g = audioCtx.createGain();
      env(g, 0.004, 1.05, 0.18);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      o1.type = "sine";
      o2.type = "sine";
      const f = 392;
      o1.frequency.setValueAtTime(f, t0);
      o2.frequency.setValueAtTime(f * 2.01, t0);

      const g2 = audioCtx.createGain();
      g2.gain.value = 0.28;
      o2.connect(g2); g2.connect(g);
      o1.connect(g);
      connectTo(g, true);

      o1.start(t0); o2.start(t0);
      o1.stop(t0 + 1.12); o2.stop(t0 + 0.95);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { g2.disconnect(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "deepbowl") {
      // Deep Bowl
      lp.frequency.value = 3600;
      const g = audioCtx.createGain();
      env(g, 0.012, 2.6, 0.22);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      o1.type = "sine";
      o2.type = "sine";
      const f = 170;
      o1.frequency.setValueAtTime(f, t0);
      o2.frequency.setValueAtTime(f * 2.02, t0);
      o2.detune.setValueAtTime(4, t0);

      o1.connect(g);
      o2.connect(g);
      connectTo(g, true);

      o1.start(t0); o2.start(t0);
      o1.stop(t0 + 2.9); o2.stop(t0 + 2.5);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "glass") {
      // Glass Ping
      lp.frequency.value = 5600;
      const g = audioCtx.createGain();
      env(g, 0.003, 1.10, 0.14);

      const carrier = audioCtx.createOscillator();
      const mod = audioCtx.createOscillator();
      const modG = audioCtx.createGain();
      carrier.type = "sine";
      mod.type = "sine";

      const base = 1245;
      carrier.frequency.setValueAtTime(base, t0);
      mod.frequency.setValueAtTime(base * 5.5, t0);
      modG.gain.setValueAtTime(0, t0);
      modG.gain.linearRampToValueAtTime(35, t0 + 0.015);
      modG.gain.exponentialRampToValueAtTime(0.001, t0 + 0.35);

      mod.connect(modG);
      modG.connect(carrier.frequency);

      carrier.connect(g);
      connectTo(g, true);

      carrier.start(t0); mod.start(t0);
      carrier.stop(t0 + 1.18); mod.stop(t0 + 0.45);

      cleanup.push(() => { try { carrier.stop(); } catch {} });
      cleanup.push(() => { try { mod.stop(); } catch {} });
      cleanup.push(() => { try { modG.disconnect(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "waterdrop") {
      // Water Drop
      lp.frequency.value = 5200;
      const g = audioCtx.createGain();
      env(g, 0.002, 0.35, 0.16);

      const o = audioCtx.createOscillator();
      o.type = "sine";
      o.frequency.setValueAtTime(1100, t0);
      o.frequency.exponentialRampToValueAtTime(520, t0 + 0.14);
      o.connect(g);
      connectTo(g, true);

      o.start(t0);
      o.stop(t0 + 0.38);

      cleanup.push(() => { try { o.stop(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "marimba") {
      // Marimba Click
      lp.frequency.value = 3600;
      const g = audioCtx.createGain();
      env(g, 0.002, 0.55, 0.18);

      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      o1.type = "sine";
      o2.type = "sine";
      const f = 660;
      o1.frequency.setValueAtTime(f, t0);
      o2.frequency.setValueAtTime(f * 3.0, t0);

      const g2 = audioCtx.createGain();
      g2.gain.value = 0.18;
      o2.connect(g2); g2.connect(g);
      o1.connect(g);
      connectTo(g, false);

      o1.start(t0); o2.start(t0);
      o1.stop(t0 + 0.62); o2.stop(t0 + 0.34);

      cleanup.push(() => { try { o1.stop(); } catch {} });
      cleanup.push(() => { try { o2.stop(); } catch {} });
      cleanup.push(() => { try { g2.disconnect(); } catch {} });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else if (type === "shimmer") {
      // Shimmer Bell
      lp.frequency.value = 6000;
      const g = audioCtx.createGain();
      env(g, 0.002, 0.75, 0.12);

      const freqs = [1568, 1760, 2093];
      const oscs = freqs.map((f) => {
        const o = audioCtx.createOscillator();
        o.type = "sine";
        o.frequency.setValueAtTime(f, t0);
        o.detune.setValueAtTime((Math.random()*10)-5, t0);
        o.connect(g);
        return o;
      });
      connectTo(g, true);
      oscs.forEach(o => o.start(t0));
      oscs.forEach(o => o.stop(t0 + 0.85));

      cleanup.push(() => { oscs.forEach(o => { try { o.stop(); } catch {} }); });
      cleanup.push(() => { try { g.disconnect(); } catch {} });

    } else {
      return;
    }

    // Register active stop so Pause/Reset can kill it.
    activeBellStops.push(stop);

    // Auto cleanup
    setTimeout(() => {
      const idx = activeBellStops.indexOf(stop);
      if (idx >= 0) activeBellStops.splice(idx, 1);
      try { stop(); } catch {}
    }, 4000);
  };

  // -----------------------------
  // Persistence
  // -----------------------------
  const save = () => {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); } catch {}
  };
  const load = () => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      settings = { ...settings, ...obj };
    } catch {}
  };

  // -----------------------------
  // Breath cycle
  // -----------------------------
  const readPattern = () => {
    const inhale = clamp(parseInt(inhaleEl.value || "4", 10), 1, 30);
    const hold1  = clamp(parseInt(hold1El.value  || "0", 10), 0, 30);
    const exhale = clamp(parseInt(exhaleEl.value || "4", 10), 1, 30);
    const hold2  = clamp(parseInt(hold2El.value  || "0", 10), 0, 30);

    settings.inhale = inhale;
    settings.hold1  = hold1;
    settings.exhale = exhale;
    settings.hold2  = hold2;
    save();

    phases = [
      { name: "INHALE", seconds: inhale, mode: "up" },
      ...(hold1 > 0 ? [{ name: "HOLD", seconds: hold1, mode: "hold_high" }] : []),
      { name: "EXHALE", seconds: exhale, mode: "down" },
      ...(hold2 > 0 ? [{ name: "HOLD", seconds: hold2, mode: "hold_low" }] : []),
    ];

    const cycleSeconds = phases.reduce((a,p) => a + p.seconds, 0);
    cycleInfo.textContent = `Cycle: ${cycleSeconds}s • Inhale ${inhale}s, Hold ${hold1}s, Exhale ${exhale}s, Hold ${hold2}s`;
  };

  const applyPreset = (key) => {
    const p = PRESETS[key] || PRESETS.box;
    settings.preset = key;
    inhaleEl.value = p.inhale;
    hold1El.value = p.hold1;
    exhaleEl.value = p.exhale;
    hold2El.value = p.hold2;
    save();
    readPattern();
  };

  // -----------------------------
  // Timer
  // -----------------------------
  const setSessionMinutes = (min) => {
    const m = clamp(min, 1, 180);
    settings.sessionSeconds = m * 60;
    sessionTotal = settings.sessionSeconds;
    sessionRemaining = sessionTotal;
    updateSessionReadout();
    save();
    [...timerChips.querySelectorAll(".chip")].forEach(ch => {
      ch.classList.toggle("active", parseInt(ch.dataset.min, 10) === m);
    });
  };
  const updateSessionReadout = () => {
    sessionLeftEl.textContent = mmss(Math.ceil(sessionRemaining));
  };

  // -----------------------------
  // Wake lock
  // -----------------------------
  let wakeLock = null;
  const setKeepAwake = async (on) => {
    settings.keepAwake = on;
    toggleSwitch(wakeSwitch, on);
    toggleWake.setAttribute("aria-pressed", String(on));
    save();

    if (!("wakeLock" in navigator)) return;
    try {
      if (on && running && !wakeLock) {
        wakeLock = await navigator.wakeLock.request("screen");
        wakeLock.addEventListener("release", () => { wakeLock = null; });
      }
      if (!on && wakeLock) {
        await wakeLock.release();
        wakeLock = null;
      }
    } catch { wakeLock = null; }
  };

  // -----------------------------
  // UI helpers
  // -----------------------------
  const setStatus = (mode) => {
    statusDot.classList.remove("running","paused");
    if (mode === "running") statusDot.classList.add("running");
    if (mode === "paused") statusDot.classList.add("paused");
    statusText.textContent = mode === "running" ? "Running" : mode === "paused" ? "Paused" : "Idle";
  };
  const toggleSwitch = (el, on) => el.classList.toggle("on", !!on);

  const setBellOnPhase = (on) => {
    settings.bellOnPhase = on;
    toggleSwitch(bellPhaseSwitch, on);
    toggleBellPhase.setAttribute("aria-pressed", String(on));
    save();
  };
  const setBellOnEnd = (on) => {
    settings.bellOnEnd = on;
    toggleSwitch(bellEndSwitch, on);
    toggleBellEnd.setAttribute("aria-pressed", String(on));
    save();
  };

  const lockInputs = (locked) => {
    const disable = (el) => el.disabled = locked;
    [
      ...timerChips.querySelectorAll("button"),
      customMinutes, applyCustom,
      presetSelect, inhaleEl, hold1El, exhaleEl, hold2El,
      phaseBellSelect, endBellSelect, bellVolumeEl,
      previewPhaseBell, previewEndBell
    ].forEach(disable);
  };

  // -----------------------------
  // Engine
  // -----------------------------
  const resetEngine = () => {
    readPattern();
    phaseIndex = 0;
    phaseRemaining = phases[0]?.seconds ?? 0;
    phaseStartTs = 0;
    lastTickTs = 0;
    sessionTotal = settings.sessionSeconds;
    sessionRemaining = sessionTotal;

    orb.style.transform = "scale(0.72)";
    phaseBig.textContent = "Ready";
    phaseSub.textContent = "Select a timer, choose a pattern, then Start.";
    phaseLeftEl.textContent = "Phase: --";
    updateSessionReadout();
  };

  const nextPhase = async () => {
    phaseIndex = (phaseIndex + 1) % phases.length;
    phaseStartTs = performance.now();
    phaseRemaining = phases[phaseIndex].seconds;

    if (settings.bellOnPhase) {
      await playBell(settings.phaseBell);
    }
  };

  const render = (now) => {
    if (!running) return;

    const dt = (now - lastTickTs) / 1000;
    lastTickTs = now;

    if (!paused) {
      sessionRemaining = Math.max(0, sessionRemaining - dt);

      const p = phases[phaseIndex];
      const elapsedInPhase = (now - phaseStartTs) / 1000;
      const left = Math.max(0, p.seconds - elapsedInPhase);
      phaseRemaining = left;

      if (sessionRemaining <= 0.00001) {
        endSession();
        return;
      }

      if (elapsedInPhase >= p.seconds - 0.00001) {
        nextPhase();
      }

      const minS = 0.68, maxS = 1.02;
      const prog = p.seconds > 0 ? clamp(elapsedInPhase / p.seconds, 0, 1) : 1;
      let target = minS;

      if (p.mode === "up") target = minS + (maxS - minS) * prog;
      else if (p.mode === "down") target = maxS - (maxS - minS) * prog;
      else if (p.mode === "hold_high") target = maxS;
      else if (p.mode === "hold_low") target = minS;

      orb.style.transform = `scale(${target.toFixed(4)})`;

      phaseBig.textContent = p.name;
      phaseSub.textContent = `${p.name === "INHALE" ? "Breathe in" : p.name === "EXHALE" ? "Breathe out" : "Stay still"} — ${Math.ceil(left)}s`;
      phaseLeftEl.textContent = `Phase: ${Math.ceil(left)}s`;

      updateSessionReadout();
    }

    requestAnimationFrame(render);
  };

  const startSession = async () => {
    readPattern();
    if (phases.length === 0) return;

    await ensureAudio(); // unlock audio on start tap
    stopAllBells();

    running = true;
    paused = false;

    lockInputs(true);
    btnStart.disabled = true;
    btnPause.disabled = false;
    btnReset.disabled = false;

    phaseIndex = 0;
    phaseStartTs = performance.now();
    lastTickTs = phaseStartTs;
    phaseRemaining = phases[0].seconds;

    setStatus("running");
    if (settings.keepAwake) await setKeepAwake(true);

    requestAnimationFrame(render);
  };

  const pauseSession = async () => {
    if (!running) return;
    stopAllBells();

    paused = !paused;
    if (!paused) {
      const now = performance.now();
      phaseStartTs = now - ((phases[phaseIndex].seconds - phaseRemaining) * 1000);
      lastTickTs = now;
      setStatus("running");
      if (settings.keepAwake) await setKeepAwake(true);
    } else {
      setStatus("paused");
      if (wakeLock) await setKeepAwake(false);
    }
    btnPause.textContent = paused ? "Resume" : "Pause";
  };

  const endSession = async () => {
    running = false;
    paused = false;
    stopAllBells();

    setStatus("idle");
    btnPause.textContent = "Pause";
    btnStart.disabled = false;
    btnPause.disabled = true;
    btnReset.disabled = true;

    lockInputs(false);

    sessionRemaining = 0;
    updateSessionReadout();
    phaseLeftEl.textContent = "Phase: --";
    phaseBig.textContent = "Done";
    phaseSub.textContent = "Session complete.";

    if (settings.bellOnEnd) {
      await playBell(settings.endBell);
      setTimeout(() => { playBell(settings.endBell); }, 320);
    }

    if (wakeLock) await setKeepAwake(false);
  };

  const resetSession = async () => {
    running = false;
    paused = false;
    stopAllBells();

    setStatus("idle");
    btnPause.textContent = "Pause";
    btnStart.disabled = false;
    btnPause.disabled = true;
    btnReset.disabled = true;

    lockInputs(false);
    if (wakeLock) await setKeepAwake(false);

    resetEngine();
  };

  // -----------------------------
  // Events
  // -----------------------------
  btnStart.addEventListener("click", startSession);
  btnPause.addEventListener("click", pauseSession);
  btnReset.addEventListener("click", resetSession);

  btnPreviewPhase.addEventListener("click", async () => {
    settings.phaseBell = phaseBellSelect.value;
    save();
    await playBell(settings.phaseBell);
  });

  previewPhaseBell.addEventListener("click", async () => {
    settings.phaseBell = phaseBellSelect.value;
    save();
    await playBell(settings.phaseBell);
  });

  previewEndBell.addEventListener("click", async () => {
    settings.endBell = endBellSelect.value;
    save();
    await playBell(settings.endBell);
  });

  phaseBellSelect.addEventListener("change", () => {
    settings.phaseBell = phaseBellSelect.value;
    save();
  });

  endBellSelect.addEventListener("change", () => {
    settings.endBell = endBellSelect.value;
    save();
  });

  bellVolumeEl.addEventListener("input", () => setBellVolume(parseInt(bellVolumeEl.value, 10)));

  timerChips.addEventListener("click", (e) => {
    const b = e.target.closest("button[data-min]");
    if (!b) return;
    setSessionMinutes(parseInt(b.dataset.min, 10));
  });

  applyCustom.addEventListener("click", () => {
    const m = clamp(parseInt(customMinutes.value || "10", 10), 1, 180);
    setSessionMinutes(m);
  });

  presetSelect.addEventListener("change", () => applyPreset(presetSelect.value));
  [inhaleEl, hold1El, exhaleEl, hold2El].forEach(el => el.addEventListener("change", readPattern));

  const clickableToggle = (wrapEl, getCurrent, setCurrent) => {
    const act = () => setCurrent(!getCurrent());
    wrapEl.addEventListener("click", act);
    wrapEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); act(); }
    });
  };

  clickableToggle(toggleBellPhase, () => settings.bellOnPhase, (v) => setBellOnPhase(v));
  clickableToggle(toggleBellEnd, () => settings.bellOnEnd, (v) => setBellOnEnd(v));
  clickableToggle(toggleWake, () => settings.keepAwake, (v) => setKeepAwake(v));

  // -----------------------------
  // Init
  // -----------------------------
  const markToggles = () => {
    toggleSwitch(wakeSwitch, !!settings.keepAwake);
    toggleWake.setAttribute("aria-pressed", String(!!settings.keepAwake));
  };

  load();

  customMinutes.value = String(Math.round(settings.sessionSeconds / 60));
  setSessionMinutes(Math.round(settings.sessionSeconds / 60));

  presetSelect.value = settings.preset;
  inhaleEl.value = settings.inhale;
  hold1El.value = settings.hold1;
  exhaleEl.value = settings.exhale;
  hold2El.value = settings.hold2;
  readPattern();

  setBellOnPhase(!!settings.bellOnPhase);
  setBellOnEnd(!!settings.bellOnEnd);

  phaseBellSelect.value = settings.phaseBell || "bowl";
  endBellSelect.value = settings.endBell || "chime";

  bellVolumeEl.value = String(settings.bellVolume);
  setBellVolume(settings.bellVolume);

  markToggles();
  resetEngine();
})();
</script>
</body>
</html>
